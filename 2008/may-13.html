<h1>Common nHibernate exceptions and a question</h1>
<p>I often get asked question about nHibernate issues the question discussed last in this post is often brought up. But lets start out with a few simple exceptions that can sometimes take up more of your time than you would like.</p>  <p><strong>&quot;NHibernate.MappingException : Unknown entity class: MyNamespace.With.Persistent.Class&quot;</strong></p>  <p>You are trying to use a class as persistent that nHibernate wouldn't know how to handle. The number one reason for this error is that you have mapping files as embedded resources and that you forgot to actually embed the mapping file.</p>  <p><strong>&quot;NHibernate.MappingException : persistent class ClassName not found&quot; </strong><strong>or &quot;</strong><strong>NHibernate.MappingException : associated class not found: ClassName&quot;</strong></p>  <p>This is usually an error in your mapping, nHibernate can't find the class you reference in your mapping. This is often caused by typos or missing to specify in which assembly or namespace your persistent class is to be found. You can specify a default assembly and namespace in the &lt;hibernate-mapping&gt; element or you can write the name of your classes with the assembly and namespace specified on the form &quot;Namespace.ClassName, Assembly&quot;.</p>  <p><strong>&quot;NHibernate.InvalidProxyTypeException : The following types may not be used as proxies&quot;</strong></p>  <p>This is a classic, if you want to use nHibernates lazyloading features you need to specify your classes properties as virtual so nHibernate can create proxies for you. If you don't need to use lazyloading on specific type mark these types with lazy=&quot;false&quot; in the class element, and you won't have to mark its properties as virtual.</p>  <p>So that's a handful of the most common exceptions when starting out with nHibernate. Lets move on to a question I have answered quite a few times. People often want to minimize the number of roundtrip's to the database by joining and retrieving larger resultsets and have nHibernate transform this larger set of results into the correct object graph. Whether this is a good optimization depends heavily on the expected data since it could result in a huge amount of redundant data transferred between database and application. But nonetheless the thing that often tricks people is illustrated by the following test:</p>  <pre class="code-csharp" name="code">//Assumme we have 2 invoices with 3 invoicelines each
IList&lt;Invoice&gt; invoices = s.CreateCriteria(typeof (Invoice)).SetFetchMode(&quot;InvoiceLines&quot;, FetchMode.Join).List&lt;Invoice&gt;();
Assert.AreEqual(2, invoices.Count);</pre>

<p>This test will fail, because you actually get 6 invoice entities back. That's because the resultset contains duplicate invoices (one for each InvoiceLine) and nHibernate transforms these into invoice instances. One way to fix this is to specify that you want distinct root entities back. This is done by specifying a result-transformer like this:</p>

<pre class="code-csharp" name="code">IList&lt;Invoice&gt; invoices =
                s.CreateCriteria(typeof (Invoice)).
                SetFetchMode(&quot;InvoiceLines&quot;, FetchMode.Join).
                SetResultTransformer(CriteriaUtil.DistinctRootEntity).
                List&lt;Invoice&gt;();</pre>

<p>So what if your data isn't suitable for joining, you might end up with the large resultset I mentioned earlier? And we don't want to hit the N+1 Select problem by selecting the InvoiceLines for each of the fetched Invoice's. That's were nHibernates batch fetching can be used. We have retrieved all the Invoices we want to use and afterwards we want to select the invoicelines for those. We can specify that our InvoiceLines should be retrieved in batches by specifying a batch-size on the collection in our mapping file.</p>

<pre class="code-xml" name="code">&lt;set name=&quot;InvoiceLines&quot; batch-size=&quot;20&quot;&gt;
	&lt;key column=&quot;InvoiceID&quot; /&gt;
	&lt;one-to-many class=&quot;InvoiceLine&quot; /&gt;
&lt;/set&gt;</pre>

<p>I just used 20 as an example, this means that nHibernate will fetch the InvoiceLines for 20 Invoices at a time. So this will result in two roundtrip's(in our example case), and this without fetching duplicate data in the resultsets. You could optimize some scenarios like the one above using MultiQuery or MultiCriteria, that is sending multiple queries in one roundtrip, but that's another story.</p>